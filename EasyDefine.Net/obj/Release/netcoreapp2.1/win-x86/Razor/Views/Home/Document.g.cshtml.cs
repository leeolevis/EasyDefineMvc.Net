#pragma checksum "E:\主站\框架\EasyDefineMvc.Net.Core\EasyDefine.Net\Views\Home\Document.cshtml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "3278064de1e35d1e66597e68ac2a37613ed5d2c9"
// <auto-generated/>
#pragma warning disable 1591
[assembly: global::Microsoft.AspNetCore.Razor.Hosting.RazorCompiledItemAttribute(typeof(AspNetCore.Views_Home_Document), @"mvc.1.0.view", @"/Views/Home/Document.cshtml")]
[assembly:global::Microsoft.AspNetCore.Mvc.Razor.Compilation.RazorViewAttribute(@"/Views/Home/Document.cshtml", typeof(AspNetCore.Views_Home_Document))]
namespace AspNetCore
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.Rendering;
    using Microsoft.AspNetCore.Mvc.ViewFeatures;
    [global::Microsoft.AspNetCore.Razor.Hosting.RazorSourceChecksumAttribute(@"SHA1", @"3278064de1e35d1e66597e68ac2a37613ed5d2c9", @"/Views/Home/Document.cshtml")]
    public class Views_Home_Document : global::Microsoft.AspNetCore.Mvc.Razor.RazorPage<dynamic>
    {
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_0 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("rel", new global::Microsoft.AspNetCore.Html.HtmlString("stylesheet"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_1 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("href", new global::Microsoft.AspNetCore.Html.HtmlString("~/assets/css/main.css"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_2 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("href", new global::Microsoft.AspNetCore.Html.HtmlString("~/assets/css/Catalog.css"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_3 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("href", new global::Microsoft.AspNetCore.Html.HtmlString("~/"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_4 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("class", new global::Microsoft.AspNetCore.Html.HtmlString("debug"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_5 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("src", new global::Microsoft.AspNetCore.Html.HtmlString("~/images/debug.jpg"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_6 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("src", new global::Microsoft.AspNetCore.Html.HtmlString("~/images/demo.png"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_7 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("width", new global::Microsoft.AspNetCore.Html.HtmlString("500"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_8 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("height", new global::Microsoft.AspNetCore.Html.HtmlString("600"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_9 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("href", new global::Microsoft.AspNetCore.Html.HtmlString("~/download/EasyDefine.Demo.rar"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        private static readonly global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute __tagHelperAttribute_10 = new global::Microsoft.AspNetCore.Razor.TagHelpers.TagHelperAttribute("class", new global::Microsoft.AspNetCore.Html.HtmlString("subpage"), global::Microsoft.AspNetCore.Razor.TagHelpers.HtmlAttributeValueStyle.DoubleQuotes);
        #line hidden
        #pragma warning disable 0169
        private string __tagHelperStringValueBuffer;
        #pragma warning restore 0169
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperExecutionContext __tagHelperExecutionContext;
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperRunner __tagHelperRunner = new global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperRunner();
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperScopeManager __backed__tagHelperScopeManager = null;
        private global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperScopeManager __tagHelperScopeManager
        {
            get
            {
                if (__backed__tagHelperScopeManager == null)
                {
                    __backed__tagHelperScopeManager = new global::Microsoft.AspNetCore.Razor.Runtime.TagHelpers.TagHelperScopeManager(StartTagHelperWritingScope, EndTagHelperWritingScope);
                }
                return __backed__tagHelperScopeManager;
            }
        }
        private global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.HeadTagHelper __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_HeadTagHelper;
        private global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper;
        private global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.BodyTagHelper __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_BodyTagHelper;
        #pragma warning disable 1998
        public async override global::System.Threading.Tasks.Task ExecuteAsync()
        {
            BeginContext(0, 25, true);
            WriteLiteral("<!DOCTYPE HTML>\r\n<html>\r\n");
            EndContext();
            BeginContext(25, 265, false);
            __tagHelperExecutionContext = __tagHelperScopeManager.Begin("head", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagAndEndTag, "483685add7fe41f59f790756c85ac083", async() => {
                BeginContext(31, 133, true);
                WriteLiteral("\r\n    <title></title>\r\n    <meta charset=\"utf-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n    ");
                EndContext();
                BeginContext(164, 54, false);
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("link", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.SelfClosing, "b75c187904d949b0b0a3ef3b54348c54", async() => {
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_0);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_1);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                EndContext();
                BeginContext(218, 6, true);
                WriteLiteral("\r\n    ");
                EndContext();
                BeginContext(224, 57, false);
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("link", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.SelfClosing, "dba4baa2f9f642b7ac8629f129b498d2", async() => {
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_0);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_2);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                EndContext();
                BeginContext(281, 2, true);
                WriteLiteral("\r\n");
                EndContext();
            }
            );
            __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_HeadTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.HeadTagHelper>();
            __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_HeadTagHelper);
            await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
            if (!__tagHelperExecutionContext.Output.IsContentModified)
            {
                await __tagHelperExecutionContext.SetOutputContentAsync();
            }
            Write(__tagHelperExecutionContext.Output);
            __tagHelperExecutionContext = __tagHelperScopeManager.End();
            EndContext();
            BeginContext(290, 2, true);
            WriteLiteral("\r\n");
            EndContext();
            BeginContext(292, 38206, false);
            __tagHelperExecutionContext = __tagHelperScopeManager.Begin("body", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagAndEndTag, "57cc4ba1709543fb9ee1eafeb9b801d6", async() => {
                BeginContext(314, 203, true);
                WriteLiteral("\r\n\r\n    <!-- Header -->\r\n    <header id=\"header\">\r\n        <div class=\"inner\">\r\n            <a class=\"logo\"><strong>EasyDefine Mvc</strong> for .Net Core</a>\r\n            <nav id=\"nav\">\r\n                ");
                EndContext();
                BeginContext(517, 19, false);
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("a", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagAndEndTag, "d677569f6ca64af98d6115b14acb192f", async() => {
                    BeginContext(530, 2, true);
                    WriteLiteral("首页");
                    EndContext();
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_3);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                EndContext();
                BeginContext(536, 7936, true);
                WriteLiteral(@"
                <a href=""/Home/Document"">文档</a>
                <a href=""https://github.com/shayuxiang/EasyDefineMvc.Net"">Git</a>
                <a href=""/Home/Document#wfw"">微服务</a>
                <a href=""/Home/About"">关于</a>
            </nav>
            <a href=""#navPanel"" class=""navPanelToggle""><span class=""fa fa-bars""></span></a>
        </div>
    </header>
    <div class=""Catalog inner"">
        <a> 1、安装及Startup的配置 </a>
        <br />
        <a class=""CatalogLink"" href=""#content"">安装 EasyDefine 全局配置</a>
        <br />
        <a class=""CatalogLink"" href=""#startup"">配置和StartUp的注入</a>
        <br />
        <a class=""CatalogLink"" href=""#qudong"">装载驱动接口</a>
        <br />
        <a class=""CatalogLink"" href=""#ceshijieguo"">测试安装结果</a>
        <br />

        <a> 2、实时服务层 </a>
        <br />
        <a class=""CatalogLink"" href=""#lxscritp"">类型标记ScriptClass</a>
        <br />
        <a class=""CatalogLink"" href=""#inject"">注入标记Inject</a>
        <br />
        <a class=""CatalogLink"" hre");
                WriteLiteral(@"f=""#ScriptMethod"">方法标记ScriptMethod</a>
        <br />

        <a> 3、数据访问层 </a>
        <br />

        <a class=""CatalogLink"" href=""#mysql"">MySql的连接</a>
        <br />
        <a class=""CatalogLink"" href=""#zck"">主从库</a>
        <br />
        <a class=""CatalogLink"" href=""#cxbj"">查询标记</a>
        <br />
        <a class=""CatalogLink"" href=""#tbyb"">同步/异步</a>
        <br />
        <a class=""CatalogLink"" href=""#zsg"">增改删标记</a>
        <br />
        <a class=""CatalogLink"" href=""#swcl"">事务处理</a>
        <br />
        <a class=""CatalogLink"" href=""#dtdx"">动态对象</a>
        <br />

        <a> 4、接口辅助标注 </a>
        <br />

        <a class=""CatalogLink"" href=""#apid"">[ApiDescription]标记</a>
        <br />
        <a class=""CatalogLink"" href=""#apidom"">[ApiDom]标记</a>
        <br />
        <a class=""CatalogLink"" href=""#dtwd"">动态接口文档</a>
        <br />
        <a class=""CatalogLink"" href=""#vue"">Vue.js的对接</a>
        <br />

        <a> 5、微服务的构建 </a>
        <br />

        <a class=""CatalogL");
                WriteLiteral(@"ink"" href=""#oce"">对接Ocelot</a>
        <br />
        <a class=""CatalogLink"" href=""#khdwz"">客户端网站的引用</a>
        <br />
        <a class=""CatalogLink"" href=""#fwsq"">服务授权</a>
        <br />

        <a> 6、更多 </a>
        <br />
        <a class=""CatalogLink"" href=""#rz"">日志</a>
        <br />
        <a class=""CatalogLink"" href=""#gnqr"">功能嵌入</a>
        <br />
        <a class=""CatalogLink"" href=""#mxscq"">模型生成器</a>
        <br />
        <a class=""CatalogLink"" href=""#qtsjk"">其它数据库</a>
        <br />
        <a class=""CatalogLink"" href=""#sq"">社区</a>
        <br />

    </div>
    <section id=""main"" class=""wrapper"">
        <div class=""inner"">
            <header class=""align-center"">
                <h2>开发手册</h2>
                <p> Development Manual </p>
            </header>
            <hr class=""major"" />
            <!-- 1 -->
            <h3>安装及StartUp的配置</h3>
            <h2 id=""content"" name=""content"">安装EasyDefine全局配置</h2>
            <h6>
                全局配置组件:请使用Nuget打包 EasyDe");
                WriteLiteral(@"fine.Configuration.dll，该动态库是EasyDefine抽象MVC业务层和数据访问层之间进行交互的共有抽象。
            </h6>
            <pre>
            <code>PM> Install-Package EasyDefine.Configuration -Version 1.0.3.1 </code>
            </pre>
            <h6>
                服务层组件:请使用Nuget打包 EasyDefine.ServiceFramework.dll，该动态库封装EasyDefine服务层的逻辑，其提供的标注组件可以快速地帮助业务层定义逻辑，帮助业务层动态地编译其具体实现类。使得开发人员更加专注于业务交互。
            </h6>
            <pre>
            <code>PM> Install-Package EasyDefine.ServiceFramework -Version 1.0.3.3 </code>
            </pre>
            <h6>
                数据访问层组件:请使用Nuget打包 EasyDefine.Dapper.dll，该动态库 EasyDefine提供对Dapper访问底层MySQL数据仓储的抽象，提供标注组件可以快速地实现数据的查询和命令的执行，并且提供动态实体映射的支持，向上层服务提供支持。
            </h6>
            <pre>
            <code>PM> Install-Package EasyDefine.Dapper -Version 1.0.3.2 </code>
            </pre>
            <p>
                在这其中，服务层组件和数据访问层组件是可选的，也就是说，如果我们对项目进行拆分的时候。比如说按照大家的习惯：Controller-Api是一个csproj，BAL和DAL各有一个csproj(BAL，我习惯的命名是SOA，各位见谅)。然后关系是向上引用的。那么，
                全局配置组件在每");
                WriteLiteral(@"个项目中都需要安装，而服务层组件仅需安装在BAL项目中，而数据层组件仅需安装在DAL项目中.

                *请不要再Nuget下载使用1.0.3之前的版本，那是我测试的。

            </p>
            <h2 id=""startup"" name=""startup"">配置和StartUp的注入</h2>
            <p>
                appsetting.json/appsetting.Development.json配置项
                位于.json配置文件的根节点下:
            </p>
            <pre>
            <code>
                    ""EasyDefineSetting"":
                    {
                    //主库地址(只能有一个)
                    ""MasterDb"": ""server=localhost;database=test;port=3306;uid=root;pwd=unknow;"",
                    //从库地址(可以有多个,从而进行读写分离)
                    ""SlaveDb"": [
                    """",
                    """"
                    ],
                    ""SOASolution"": ""PPM.Online.SOA"",
                    ""DALSolution"": ""PPM.Online.DAL"",
                    ""DtoSolution"": ""PPM.Online.DTO""
                    }
                </code>
            </pre>
            <p>
                这里需要解释一下:MasterDb代表的是主库的连接池，而SlaveDb是从库的连接池，这是为了实现数据库级别的");
                WriteLiteral(@"读写分离而做的，首先必须保证可以连的通。一般我们只需填写MasterDb的连接字串即可。目前第一个版本，仅支持MySql数据库,后续，看情况我们会接入其它的数据库 -_-!!
            </p>
            <p>接着，我们需要对StartUp进行一下修改</p>
            <pre>
            <code>
                    public IServiceProvider ConfigureServices(IServiceCollection services)
                    {
                    //使用EasyDefine注册动态
                    #region 动态编译、注入、待封装代码

                    //注册DAL-DLL,注意DAL一定要放在SOA之前注册
                    services.AddEasyDefineDAL(typeof(ITestQueries).Assembly);
                    //注册SOA-DLL
                    services.AddEasyDefineSOA(typeof(ITest).Assembly);

                    #endregion
                    //添加MVC
                    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
                    return GetAutofacServiceProvider(services);
                    }

                    private IServiceProvider GetAutofacServiceProvider(IServiceCollection services)
                    {
                    var bu");
                WriteLiteral(@"ilder = new ContainerBuilder();
                    builder.Populate(services);
                    var container = builder.Build();
                    return new AutofacServiceProvider(container);
                    }
                </code>
            </pre>
            <p>
                如您所见，我这里使用了AutoFac对我们编译好的服务进行了注册,EasyDefine并不强制使用这种方式进行注册。只是本人懒得写了，如果您有兴趣可以试试别的方式
            </p>
            <p>
                注意1：编译的顺序一定要将DAL放在之前(如果您对服务和数据访问进行了拆分,而对于直接不写Services层，裸操作数据的懒人们，请忽略)，因为SOA服务是依赖DAL的，在下面我们会说到引用的问题。
            </p>
            <p>
                注意2: 上例中的typeof中的类型，分别是您的服务层和数据访问层的一个接口，EasyDefine默认是必须要有一个向上提供服务的接口，哪怕是个空接口，否则我们的操作没有任何意义。
                巧合的是，我们正好可以利用这个空接口，作为我们当前模组的驱动，顺便来为我们做一些辅助性的工作，在“4、接口辅助标记” 中，我会给您详细讲述。
            </p>
            <h2 id=""qudong"" name=""qudong"">装载驱动接口</h2>
            <p>
                如上面的注意2说到，我们需要使用至少一个空接口，提供给EasyDefine进行编译装载，那么这个空接口大致长这个样子：
            </p>
            <h6>这是在我数据访问层DAL类库中的空接口，我将它作为数据层的驱动:</h6>
            <");
                WriteLiteral(@"pre>
            <code>
                    [DapperLink(PointEnum = SourcePointEnum.Master, NameSpace = ""PPM.Online.OrdersData"")]
                    public interface IOrdersDataProvider{}
                </code>
            </pre>
            <h6>这是在我服务层SOA类库中的空接口，我将它作为数据层的驱动:</h6>
            <pre>
            <code>
                    [ScriptClass(NameSpace = ""PPM.Online.OrderssAPI"")] //定义类属命名空间
                    [Inject(VariableName = ""order"", Ref = typeof(IOrdersDataProvider))] //注入DAL
                    public interface IOrdersServicesProvider{}
                </code>
            </pre>
            <h2 id=""ceshijieguo"" name=""ceshijieguo"">测试安装结果</h2>
            <p>Ok,做了那么多铺垫，让我们把程序跑起来吧！为了看得清楚，请将您的MVC程序设置为控制台启动。如下图:</p>
            ");
                EndContext();
                BeginContext(8472, 46, false);
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("img", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.SelfClosing, "03da08776e45491f9e6bd428f53a41a4", async() => {
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_4);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_5);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                EndContext();
                BeginContext(8518, 2994, true);
                WriteLiteral(@"
            <p>这是我们项目中的其中一个服务，黄色字体部分是框架的编译的临时信息，红色部分是生成的临时文件位置。</p>
            <hr class=""major"" />
            <!-- 2 -->
            <h3 id=""content"" name=""content"">实时服务层</h3>
            <p>
                服务层，根据传统MVC的定义，中间的工厂类提供了另一个通用放任接口让调用者可以使用接口暴漏的方法，而无需关注架构或底层发生的怎样的变化。
                也就是说，服务层是用于选取底层服务，或者接入外部调用的。根据我个人理解，也就是对底层的数据源进行一个筛选和反馈。
            </p>
            <p>
                那么问题来了，其实在很多项目和实践中，服务层仅仅作为一个中转站，不断的在return DAL。类似地这种操作，无论对于系统还是程序员本身来说，
                都是很蠢的，完全是在浪费我们的青春。而EasyDefine对这里进行了重点的封装。使得我们 Ctrl+C Ctrl+V 更加顺手，代码也更容易看的懂。
            </p>
            <h2 id=""lxscritp"" name=""lxscritp"">类型标记ScriptClass</h2>
            <pre>
            <code>
                    [ScriptClass(NameSpace = ""Online.OrderAPI"")] //定义类属命名空间
                    public interface IOriginalOrderSOA{}
                </code>
            </pre>
            <p>
                这段代码在之前我好像已经写过了，这里我就再说一次。ScriptClass 标记到接口，则该接口被指定为服务层接口，编译器会将该接口的实例创建并映射出来。我们只需要填入一串字符，指定这个类的命名空间即可。
    ");
                WriteLiteral(@"            当然，命名空间仅仅是为了方便阅读而设定的(生成的.cs文件会包在这个命名空间下，但是并没什么卵用),与我们之前配置文件没什么关系。
            </p>


            <h2 id=""inject"" name=""inject"">注入标记Inject</h2>
            <pre>
            <code>
                    [ScriptClass(NameSpace = ""PPM.VerticalSite.Test"")] //定义类属命名空间
                    [Inject(VariableName = ""test"", Ref = typeof(ITestQueries))] //注入DAL
                    public interface ITest{}
                </code>
            </pre>
            <p>
                Inject标记，指的是向该服务，注入一个底层的数据源处理，可以同时注入多个，这与我们创建服务层的目的是符合的。
                当然，是允许您注入自定义类型以实现其特殊的处理的。
            </p>
            <h2 id=""ScriptMethod"" name=""ScriptMethod"">方法标记ScriptMethod</h2>
            <pre>
            <code>
                    [ScriptMethod(Describe = ""根据日期查出当天的成交订单统计"")]
                    Task&lt;OrderCountByDayResponse&gt; GetOrderCountByDay(string datestring);
                </code>
            </pre>
            <p>
                如您所见，SciprtMethod指明了某一个方法，为服务方法。这样，这个方法将会被放到框架中进行编译。
");
                WriteLiteral(@"            </p>
            <p>
                可能您会问，我一个接口方法体都没有，他执行个啥呢？
                这也就是EasyDefine实现的目的之一：优先照顾懒人。系统会自动找到您注入(Inject)的接口中，同名同参同返的方法，并且直接调用它。
                若多个注入(Inject)中有多个同名同参同返的方法，则会报错(系统Bug之一，以后再改吧)。
                您可能注意到了 Task&lt;T&gt; : 这再下面的“同步/异步”章节也会说到。Task 则方法自动被编译为异步方法，而没有Task 则方法自动编译为同步。
                注意:Task&lt;T&gt; Method() 和 T Method() 系统会认为他们是不同方法。
            </p>
            <hr class=""major"" />
            <!-- 3 -->
            <h3 id=""content"" name=""content"">数据访问层</h3>
            <p>
                EasyDefine数据访问层，如您所见，同SOA服务层一样，使用标注即可实现底层数据的增、改、删、查、事务等功能，而不需要自行处理繁杂的编码，
                如:
            </p>
            <pre>
            <code>
                    [DapperLink(PointEnum = SourcePointEnum.Master, NameSpace = ""PPM.Online.ExportDAL"")]
                    public interface IExportDAL
                    {
                        [DapperQuery(QueryCommand = ");
                EndContext();
                BeginContext(11513, 2559, true);
                WriteLiteral(@"@""{sql}"")]
                        Task&lt;List&lt;ExportModel&gt;&gt; GetAllHtml();

                        [DapperUpdate(Fields = ""Html"", TableName = ""T_ProductDetailTemp"")]
                        Task&lt;UpdateResult&gt; UpdateHtml(List&lt;UpdateHtmlModel&gt;    model, IDbTransaction dbTransaction);
                    }
                </code>
            </pre>

            <h2 id=""mysql"" name=""mysql"">MySql的连接</h2>
            <p>
                一条标注，一个连接,如下列代码所示:
            </p>
            <pre>
            <code>
                    [DapperLink(PointEnum = SourcePointEnum.Master, NameSpace = ""PPM.Online.ExportDAL"")]
                    public interface IExportDAL
                    { }
                </code>
            </pre>
            <p>
                DapperLink 标注将当前接口及其动态的实例绑定到Master的数据库。EasyDefine允许在一个项目中绑定不同的从库，
                从而方便地实现读写分离。具体数据库的配置我们需要在appsettings.json和appsettings.Development.json(调试环境)中进行配置
            </p>
            <pre>
            <code");
                WriteLiteral(@">
                ""EasyDefineSetting"": {
                //主库地址
                ""MasterDb"": ""server=127.0.0.1;database=db;port=3306;uid=root;pwd=abcd;"",
                ""SOASolution"": ""SOASolution1"",
                ""DALSolution"": ""DALSolution1"",
                ""DtoSolution"": ""DtoSolution1""
                }
            </code>
            </pre>
            <h2 id=""zck"" name=""zck"">主从库</h2>
            <p>
                接上，在json配置文件中我们可以通过SalveDb的节点，配置多个从库服务器，进而实现读写分离。在使用时，通过指定SlaveDb的序号，进行分配式的调用
            </p>
            <pre>
            <code>
                ""EasyDefineSetting"": {
                //主库地址
                ""MasterDb"": ""server=127.0.0.1;database=db;port=3306;uid=root;pwd=abcd;"",
                //从库地址
                ""SlaveDb"": [
                """",
                """"
                ],
                ""SOASolution"": ""SOASolution1"",
                ""DALSolution"": ""DALSolution1"",
                ""DtoSolution"": ""DtoSolution1""
                }
            </code");
                WriteLiteral(@">
            </pre>
            <pre>
            <code>
                [DapperLink(PointEnum = SourcePointEnum.Slave,SlaveId = 1, NameSpace = ""PPM.Online.ExportDAL"")]
                public interface IExportDAL{}
            </code>
            </pre>
            <h2 id=""cxbj"" name=""cxbj"">查询标记</h2>
            <p>
                在[DapperLink]标记的类中对方法使用[DapperQuery]标记，辅以适当的SQL语句，即可实现查询。如：
            </p>
            <pre>
            <code>
                    [DapperQuery(QueryCommand = ");
                EndContext();
                BeginContext(14073, 283, true);
                WriteLiteral(@"@""SELECT Name,ExpirationDate,Command from T_Rank where state = 0 ORDER BY OrderIndex desc"")]
                    Task&lt;dynamic&gt; GetRankAsync();
                </code>
            </pre>
            <pre>
            <code>
                    [DapperQuery(QueryCommand = ");
                EndContext();
                BeginContext(14357, 65, true);
                WriteLiteral("@\"SELECT * from T_Advertising a where a.State =0 and a.ShowPos = ");
                EndContext();
                BeginContext(14423, 246, true);
                WriteLiteral("@showPos\")]\r\n                    Task&lt;IEnumerable&lt;dynamic&gt;&gt; GetAdvertisingsByPosAsync(int showPos);\r\n                </code>\r\n            </pre>\r\n            <p>\r\n                如上方代码所示，被标注DapperQuery的接口会自动生成类型和方法以匹配标注。在设置方法时，SQL中的参数");
                EndContext();
                BeginContext(14670, 2892, true);
                WriteLiteral(@"@showPos需要和方法参数一毛一样。
                查询的结果会自动地转为方法返回值的类型。如果转型失败，则启动时动态编译会通过不了。

                这里有个万能的策略，即返回对象为dynamich或IEnumerable&lt;dynamic&gt;等。这样的返回编码人员可以在后续的代码中进行判断和使用。
            </p>
            <h2 id=""tbyb"" name=""tbyb"">同步/异步</h2>
            <p>
                EasyDefine不仅会根据返回值类型自动生成返回方法，同时还会根据返回的类型中的Task，自动生成异步方法。即,有Task&lt;?&gt;为异步方法。
                调用时需要await。无Task为同步方法。调用时不需要await.
            </p>
            <h2 id=""zsg"" name=""zsg"">增改删标记</h2>
            <p>
                在easyDefine中的增改删标记非常简单，原理同DapperQuery一样，他们分别长这样:
            </p>
            <pre>
            <code>
                    [DapperInsert(Fields = ""TradeNo,PlatTradeNo,PayWay,ReceiptAmount,GmtPayment,TraceNoId, OutUser,UserTip,DiscountAmount,State,CourierNum"", TableName = ""T_OriginalOrder"")]
                    Task&lt;InsertResult&gt; AddTradeOrderAsync(List&lt;TradeOrderAddModel&gt; tradeOrderAdd, IDbTransaction transaction);

                    [DapperUpdate(Fields = ""PayDate"", TableName = ""T_Busi");
                WriteLiteral(@"nessTrace"")]
                    Task&lt;UpdateResult&gt; UpdateBusinessTraceAsync(List&lt;BusinessTraceModel&gt; businessTrace, IDbTransaction transaction);

                    [DapperDelete(TableName = ""T_User"")]
                    Task&lt;DeleteResult&gt; DeleteUser2(string WhereExp, IDbTransaction transaction);
                </code>
            </pre>
            <p>
                其中，新增和修改方法，可以使用自定义对象，装载需要新增或修改的字段，其它，就不做过多解释了。
            </p>
            <h2 id=""swcl"" name=""swcl"">事务处理</h2>
            <p>
                您可能注意到了，在上面的例子中，会有参数IDbTransaction transaction。这个参数是用来统一事务的。如果在SOA和DAL标记接口的方法中存在该参数，
                并且在调用时传入了一个非Null的实值，则这些操作都在一个事务中，事务失败，则会自动回滚。以下代码，是我在一个Action中的调用示例:
            </p>
            <pre>
            <code>
                    [HttpGet]
                    public async Task&lt;int&gt; TransUser() {
                        using (var conn = DapperBuilder.Instance.GetConnection(SourcePointEnum.Master, 0))
                        {
               ");
                WriteLiteral(@"             conn.Open();
                            IDbTransaction transaction = conn.BeginTransaction();
                            //新增三个
                            List&lt;AddedModel&gt; added = new List&lt;AddedModel&gt;();
                            added.Add(new AddedModel { nickname = ""新增1"", Name = ""Name1"" });
                            added.Add(new AddedModel { nickname = ""新增2"", Name = ""Name2"" });
                            added.Add(new AddedModel { nickname = ""新增3"", Name = ""Name3"" });
                            var iResult = await _test2.AddUser2(added, transaction); //插入结果

                            List&lt;UpdateModel&gt;  uped = new List&lt;UpdateModel&gt; ();
                            //修改第二个结果
                            uped.Add(new UpdateModel { nickname = ""测试修改11"", Name = ""666"", WhereExp = $");
                EndContext();
                BeginContext(17563, 244, true);
                WriteLiteral("@\" id = {iResult.ResultKeys[1].ToString()} \" });\r\n                            var uResult = await _test2.UpdateUser2(uped,transaction);\r\n\r\n                            //删除第三个\r\n                            var dResult = await _test2.DeleteUser2($");
                EndContext();
                BeginContext(17808, 3184, true);
                WriteLiteral(@"@"" Id = {iResult.ResultKeys[2].ToString()}"",transaction);
                            transaction.Commit();//提交事务
                            return iResult.ResultCount - dResult.ResultCount;
                        }
                    }

                </code>
            </pre>
            <h2 id=""dtdx"" name=""dtdx"">动态对象</h2>
            <hr class=""major"" />
            <p>
                如上面demo中所说。在easyDefine中，MVC的M,是不太重要的。因为所有的生成、依赖，都可以通过dynamic这个.net core 特殊类型返回出来。
                其实，这样带来了方便，可以偷懒，但却降低了严谨性。然而，频繁地修改SQL和Model。这对于一个项目来说实实在在是一个灾难。这也是Code First
                的编码模式更火的其中一个原因。
                这里，作为原生SQL的忠实簇拥。我能想到的办法，就是额外地提供一个生成器。使用该工具，可以方便地导入和导出SQL/Model。
                <a href=""../download/EdLayuiBuilder.rar"" download=""EdLayuiBuilder.rar""> 下载地址 </a>
            </p>
            <!-- 4 -->
            <h3 id=""content"" name=""content"">接口辅助标注</h3>
            <h2 id=""apid"" name=""apid"">[ApiDescription]标记</h2>
            <p>
                Controller层的接口辅助标记，是对应MVC-Contro");
                WriteLiteral(@"ller的识别标记，在接口的[GET][POST][PUT]方法上补充[ApiDescription]标记，则该Action会被框架自动识别
                出格式，使用系统方法可将其导出，以便应用于不同的客户端场景。
            </p>
            <p>接口方法如下所示:</p>
            <pre>
            <code>
                    [HttpGet]
                    [ApiDescription(""首页闪购商品查询"")]
                    public async Task&lt;JsonResult&gt; GetFlashoverBooksAsync(){
                        // Something TODO
                    }
                </code>
            </pre>
            <p>该标记声明，GetFlashoverBooksAsync方法接入EasyDefine框架，可以被后续操作的客户端引用所识别</p>
            <h2 id=""apidom"" name=""apidom"">[ApiDom]标记</h2>
            <p>
                Services层的接口辅助标记，用于抽取本项目中所有API的构造格式
            </p>
            <p>以下几乎接近固定写法:</p>
            <pre>
            <code>
                    [ApiDom(Describe = ""查询所有API接口文档结构"")]
                    ApiEnumerable GetAllApi(Assembly ass);
                </code>
            </pre>
            <h2 id=""dtwd"" name=""dtwd"">动态接口文档</h2>
            <p>我们根据之前的方法，整体联");
                WriteLiteral(@"动，导出整个系统允许对外可识别的API接口:</p>
            首先是接口层:
            <pre>
            <code>
                    [ScriptClass(NameSpace = ""EasyDefine.Test"")] //定义类属命名空间
                    public interface IProductServicesProvider{
                        [ApiDom(Describe = ""查询所有API接口文档结构"")]
                        ApiEnumerable GetAllApi(Assembly ass);
                    }
                </code>
            </pre>
            然后是Controller里的配置
            <pre>
            <code>
                    //注入驱动接口
                    private readonly IProductServicesProvider provider;
                    public ApiDomController(IProductServicesProvider _provider)
                    {
                        provider = _provider;
                    }

                    [HttpGet]
                    public JsonResult GetAllApi()
                    {
                        var ret = provider.GetAllApi(typeof(Program).Assembly);
                        return Json(ret);
                    }
");
                WriteLiteral("                </code>\r\n            </pre>\r\n            让我们看一下效果，<a>测试地址</a>\r\n            <p>\r\n                ");
                EndContext();
                BeginContext(20992, 56, false);
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("img", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.SelfClosing, "aa39995cebf944e99c8a5213b379a452", async() => {
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_6);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_7);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_8);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                EndContext();
                BeginContext(21048, 8038, true);
                WriteLiteral(@"
            </p>
            <h2 id=""vue"" name=""vue"">Vue.js的对接</h2>
            <p>
                同[ApiDom]标记，EasyDefine提供一套类似的机制，使得Vue.js可以更加快速地接入后台,而不需要针对细节单独地编码。
                在精简代码量的同时，大大地提升前端开发者的效率。前端开发者只需要将生成的包地址引入&lt;script&gt;标签即可，具
                体示例如下:
            </p>
            <h5>EasyDefine 服务端:</h5>
            Services-Provider 驱动接口：
            <pre>
                <code>
                    [ApiVue(""Areaapi"", ""http://localhost:8000/api/"", IsAuth: true, Describe = ""查询所有API接口Vue.js的对应类库"")]
                    string GetAllVue(Assembly ass);

                    [ApiJsDoc(""Areaapi"", ""http://localhost:8000/api/"", Describe = ""查询所有API接口Vue.js的文档说明"")]
                    string GetJsDoc(Assembly ass);
                </code>
            </pre>
            <hr class=""major"" />
            Controller 服务输出(这里的写法不是唯一的，你可以根据你自己的习惯写出更牛啤的代码):
            <pre>
            <code>

                    [HttpGet]
                    [ApiDescription(""获取所有VUE文档,这里的View你可以自己去排版"")");
                WriteLiteral(@"]
                    public IActionResult GetJsDoc()
                    {
                        ViewData[""content""] = provider.GetJsDoc(typeof(Program).Assembly);
                        ViewData[""Title""] = ""产品服务 Js-Doc"";
                        return View();
                    }

                    [HttpGet]
                    [ApiDescription(""获取所有VUE对象-并打包JS脚本"")]
                    public IActionResult GetAllVue()
                    {
                    Response.ContentType = ""text/javascript""; //js类型
                    var contentDisposition = ""attachment;"" + ""filename="" + HttpUtility.UrlEncode(""api_vue_prod_core.js"");//在Response的Header中设置下载文件的文件名，这样客户端浏览器才能正确显示下载的文件名，注意这里要用HttpUtility.UrlEncode编码文件名，否则有些浏览器可能会显示乱码文件名
                    Response.Headers.Add(""Content-Disposition"", new string[] { contentDisposition });
                    var retcode = System.Text.Encoding.UTF8.GetBytes(provider.GetAllVue(typeof(Program).Assembly));
                    long hasRead = 0;//变量hasRea");
                WriteLiteral(@"d用于记录已经发送了多少字节的数据到客户端浏览器
                    //如果hasRead小于contentLength，说明下载文件还没读取完毕，继续循环读取下载文件的内容，并发送到客户端浏览器
                    using (Response.Body)
                    {
                    while (hasRead < retcode.Length)
                    {
                    //HttpContext.RequestAborted.IsCancellationRequested可用于检测客户端浏览器和ASP.NET Core服务器之间的连接状态，如果HttpContext.RequestAborted.IsCancellationRequested返回true，说明客户端浏览器中断了连接
                    if (HttpContext.RequestAborted.IsCancellationRequested)
                    {
                    //如果客户端浏览器中断了到ASP.NET Core服务器的连接，这里应该立刻break，取消下载文件的读取和发送，避免服务器耗费资源
                    break;
                    }
                    var needRead = 1024;
                    if (retcode.Length - hasRead < 1024)
                    {
                    needRead = retcode.Length - Convert.ToInt32(hasRead);
                    }
                    Response.Body.Write(retcode, Convert.ToInt32(hasRead), Convert.ToInt32(needRead));//发送读取的内容数据到客户端浏览器
     ");
                WriteLiteral(@"               Response.Body.Flush();//注意每次Write后，要及时调用Flush方法，及时释放服务器内存空间
                    hasRead += needRead;//更新已经发送到客户端浏览器的字节数
                    }
                    }
                    return new EmptyResult();
                    }
                </code>
            </pre>
            <h5>EasyDefine To Vue.js:</h5>
            <pre>
            <code>
                    &lt;script src=""{你的接口地址}"" type=""text/javascript""&gt;&lt;/script&gt;
                </code>
             </pre>
            在不需要接口授权的情况下，你直接new对象，调用方法就可以使用了。至于API列表文档，直接访问上面的GetJsDoc接口即可查看。

            <hr class=""major"" />

            <!-- 5 -->
            <h3 id=""wfw"" name=""wfw"">微服务的构建</h3>
            Easydefine 支持微服务的构建技术，即将一个系统内的不同区域功能拆分到不同的API里。我们这里使用的是Ocelot，进行的构建。
            基础的配置，请参阅有关资料

            <h2 id=""oce"" name=""oce"">对接Ocelot</h2>
            以下一个对网关程序进行的配置(appsettings.json)的示例:
            <pre>
                {
                  ""ReRoutes"": [
                    // OAuth2.0授权服务");
                WriteLiteral(@"
                    {
                      ""DownstreamPathTemplate"": ""/api/{url}"",
                      ""DownstreamScheme"": ""http"",
                      ""DownstreamHostAndPorts"": [
                        {
                          ""Host"": ""localhost"",
                          ""Port"": ""7000""
                        }
                      ],
                      ""UpstreamPathTemplate"": ""/api/AuthAPI/{url}"",
                      ""UpstreamHttpMethod"": [ ""Get"", ""Post"" ]
                    },
                    // 产品基础服务
                    {
                      ""DownstreamPathTemplate"": ""/api/{url}"",
                      ""DownstreamScheme"": ""http"",
                      ""DownstreamHostAndPorts"": [
                        {
                          ""Host"": ""localhost"",
                          ""Port"": ""8001""
                        },
                        {

                          ""Host"": ""localhost"",
                          ""Port"": ""10001""
                        ");
                WriteLiteral(@"},
                        {

                          ""Host"": ""localhost"",
                          ""Port"": ""20001""
                        },
                        {

                          ""Host"": ""localhost"",
                          ""Port"": ""30001""
                        },
                        {

                          ""Host"": ""localhost"",
                          ""Port"": ""40001""
                        }
                      ],
                      ""UpstreamPathTemplate"": ""/api/ProdAPI/{url}"",
                      ""UpstreamHttpMethod"": [ ""Get"", ""Post"" ],
                      ""LoadBalancer"": ""RoundRobin"",
                      ""RateLimitOptions"": {
                        ""ClientWhitelist"": [],
                        ""EnableRateLimiting"": true,
                        ""Period"": ""1s"",
                        ""PeriodTimespan"": 1,
                        ""Limit"": 1
                      }
                    },
                    // 订单基础服务
                ");
                WriteLiteral(@"    {
                      ""DownstreamPathTemplate"": ""/api/{url}"",
                      ""DownstreamScheme"": ""http"",
                      ""DownstreamHostAndPorts"": [
                        {
                          ""Host"": ""localhost"",
                          ""Port"": ""8002""
                        }
                      ],
                      ""UpstreamPathTemplate"": ""/api/OrderAPI/{url}"",
                      ""UpstreamHttpMethod"": [ ""Get"", ""Post"" ]
                    },
                    // 用户基础服务
                    {
                      ""DownstreamPathTemplate"": ""/api/{url}"",
                      ""DownstreamScheme"": ""http"",
                      ""DownstreamHostAndPorts"": [
                        {
                          ""Host"": ""localhost"",
                          ""Port"": ""8003""
                        }
                      ],
                      ""UpstreamPathTemplate"": ""/api/UserAPI/{url}"",
                      ""UpstreamHttpMethod"": [ ""Get"", ""Post"" ]
    ");
                WriteLiteral(@"                },
                    // 运行时基础服务
                    {
                      ""DownstreamPathTemplate"": ""/api/{url}"",
                      ""DownstreamScheme"": ""http"",
                      ""DownstreamHostAndPorts"": [
                        {
                          ""Host"": ""localhost"",
                          ""Port"": ""8004""
                        }
                      ],
                      ""UpstreamPathTemplate"": ""/api/UtilAPI/{url}"",
                      ""UpstreamHttpMethod"": [ ""Get"", ""Post"" ]
                    }
                  ],
                  ""GlobalConfiguration"": {
                    ""BaseUrl"": ""http://localhost:8000""
                  }
                }
            </pre>
            <h2 id=""khdwz"" name=""khdwz"">客户端网站的引用</h2>
            <p>
                这里我提供一个示例程序，去读取由框架给出的接口，从而生成本地类的程序，");
                EndContext();
                BeginContext(29086, 55, false);
                __tagHelperExecutionContext = __tagHelperScopeManager.Begin("a", global::Microsoft.AspNetCore.Razor.TagHelpers.TagMode.StartTagAndEndTag, "0ba19c66d07b44c5bac4606e4176805c", async() => {
                    BeginContext(29127, 10, true);
                    WriteLiteral("点击完整DEMO下载");
                    EndContext();
                }
                );
                __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.UrlResolutionTagHelper>();
                __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_UrlResolutionTagHelper);
                __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_9);
                await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
                if (!__tagHelperExecutionContext.Output.IsContentModified)
                {
                    await __tagHelperExecutionContext.SetOutputContentAsync();
                }
                Write(__tagHelperExecutionContext.Output);
                __tagHelperExecutionContext = __tagHelperScopeManager.End();
                EndContext();
                BeginContext(29141, 1027, true);
                WriteLiteral(@" 
            </p>
            <h2 id=""fwsq"" name=""fwsq"">服务授权</h2>
            <p>
                这里，我们通过MVC-Filter拦截的方式，实现的OAuth授权，具体Filter实现代码如下：
            </p>
            <pre>
            <code>

                    public void OnAuthorization(AuthorizationFilterContext context)
                    {
                        context.HttpContext.Response.Headers[""Access-Control-Allow-Origin""] = ""*"";//解决拦截器添加后跨域不生效的问题
                        if (context.ModelState.IsValid)//验证参数的合法性问题。返回错误信息
                        {
                        //API展示接口不认证
                        if (context.RouteData.Values.Values.ToList().Exists(e => e.ToString().ToLower() == ""apidom"")) return;
                        //不包含Token
                        if (!context.HttpContext.Request.Headers.Keys.Contains(""Authorization""))
                        {
                        //是否含有Token
                        context.Result = new ContentResult
                        {
                        Content ");
                WriteLiteral("= $");
                EndContext();
                BeginContext(30169, 1463, true);
                WriteLiteral(@"@""{{code:401,error:""""无访问权限，未检索到授权令牌!""""}}"",
                        StatusCode = StatusCodes.Status401Unauthorized,
                        ContentType = ""text/html;charset=utf-8""
                        };
                        }
                        else
                        {
                        var vals = context.HttpContext.Request.Headers.Values;
                        var token = """";
                        var AppKey = """";
                        foreach (var _token in vals)
                        {
                        if (_token.ToString().StartsWith(""OAuth""))
                        {
                        token = _token.ToString().Replace(""OAuth"", string.Empty).Trim();
                        }
                        if (_token.ToString().StartsWith(""Key""))
                        {
                        AppKey = _token.ToString().Replace(""Key"", string.Empty).Trim();
                        }
                        }
                        Console.WriteL");
                WriteLiteral(@"ine(token);
                        //合法性检测，验证token的加密结果是否与服务器算法一致
                        var app = App.Get(AppKey);
                        var tokenInfo = app.DecryptToken(token);
                        if (!app.Check(AppKey, tokenInfo.UserPwd, tokenInfo.UserRole, tokenInfo.iss))
                        {
                        context.Result = new ContentResult
                        {
                        Content = $");
                EndContext();
                BeginContext(31633, 613, true);
                WriteLiteral(@"@""{{code:400,error:""""签名认证失败!""""}}"",
                        StatusCode = StatusCodes.Status400BadRequest,
                        ContentType = ""text/html;charset=utf-8""
                        };
                        }
                        //访问用户检测，验证token的AppKey指向的用户状态是否正常
                        var AuthUser = productServicesProvider.GetAuthUser(AppKey, app.AppSecret).Result;
                        if (AuthUser == null || AuthUser.State == 1)
                        {
                        context.Result = new ContentResult
                        {
                        Content = $");
                EndContext();
                BeginContext(32247, 1900, true);
                WriteLiteral(@"@""{{code:503,error:""""未找到用户或当前用户状态异常""""}}"",
                        StatusCode = StatusCodes.Status503ServiceUnavailable,
                        ContentType = ""text/html;charset=utf-8""
                        };
                        }
                        //访问权限检测,验证token的AppKey是否有访问本接口的权限
                        else if (!AuthUser.IsAll)
                        {
                        //获取可访问接口列表
                        var functions = productServicesProvider.GetAuthFunction(AuthUser.Id).Result;
                        var _this = functions.Where(e => e.APIRoute.ToLower() == context.RouteData.Values[""controller""].ToString().ToLower()
                        && e.APIAction.ToLower() == context.RouteData.Values[""action""].ToString().ToLower());
                        if (_this.Count() < 1)
                        {
                        context.Result = new ContentResult
                        {
                        Content = $@@""{{code:405,error:""""当前资源不可使用""""}}"",
                 ");
                WriteLiteral(@"       StatusCode = StatusCodes.Status405MethodNotAllowed,
                        ContentType = ""text/html;charset=utf-8""
                        };
                        }
                        }
                        //是否过期检测,验证token是否已超出可访问时间
                        else if (AuthUser.EndDate != null)
                        {
                        //以后拓展
                        }
                        //检验关联店铺信息是否有异常
                        else if (AuthUser.ShopId > 0)
                        {
                        //以后拓展
                        }
                        //判断Token生成时间是否过时，该判断最后加上 方便调试
                        }
                        }
                        else
                        {
                        context.Result = new ContentResult
                        {
                        Content = $");
                EndContext();
                BeginContext(34148, 3832, true);
                WriteLiteral(@"@""{{code:400,error:""""参数无效,访问失败!""""}}"",
                        StatusCode = StatusCodes.Status400BadRequest,
                        ContentType = ""text/html;charset=utf-8""
                        };
                        }
                    }
                </code>
            </pre>
            <p>网站端调用在需要授权的情况下,需要把授权类注入的RESTAPI的提交处,示例:</p>
            <pre>
            <code>

                    public static void AddServicesRefScoped(IServiceCollection services)
                    {
                        foreach (var _ref in typeof(Program).Assembly.GetTypes())
                        {
                            if (_ref.IsInterface && _ref.Name.EndsWith(""Ref""))
                            {
                                //是Ref接口类型
                                services.AddScoped(_ref, sp =>
                                {
                                    var factory = sp.GetService(typeof(Microsoft.AspNetCore.Http.IHttpContextAccessor));
                          ");
                WriteLiteral(@"          var context = ((Microsoft.AspNetCore.Http.HttpContextAccessor)factory).HttpContext;
                                    var handler = new AuthenticatedHttpClientHandler(context);
                                    var ms = typeof(RestService).GetMethods();
                                    var retobj = new object();
                                    foreach (var themethod in ms)
                                    {
                                        if (themethod.GetParameters().Length == 1 && themethod.GetParameters().FirstOrDefault().ParameterType == typeof(System.Net.Http.HttpClient))
                                        {
                                            //反射方式可能会影响页面效率，此处在上线后可还原注入内容
                                            retobj = themethod.MakeGenericMethod(new Type[] { _ref }).Invoke(_ref, new object[] {
                                            new System.Net.Http.HttpClient(handler) { BaseAddress = new Uri(Token.Host) }
                             ");
                WriteLiteral(@"               });
                                        }
                                    }
                                    return retobj;
                                });
                            }
                        }
                    }
                </code>
            </pre>
            <hr class=""major"" />

            <!-- 6 -->
            <h3 id=""content"" name=""content"">更多</h3>
            <h2 id=""rz"" name=""gnqr"">日志</h2>
            <p>
                EasyDefine提供简单的日志处理功能，开发者在Startup.cs中通过EasyDefine的拓展方法可直接注入。
            </p>
            <pre>
                <code>
                    using EasyDefine.Configuration.Lib;

                    public class Startup
                    {
                        public IServiceProvider ConfigureServices(IServiceCollection services){
                             services.AddEasyDefineLog();
                        }
                    }

                </code>
            </pre>
            <p>");
                WriteLiteral(@"
                然后在Action中直接使用
            </p>
            <pre>
                <code>
                    //信息输出
                    this.EdLog&lt;T&gt;(""打印日志"");   // T:取当前需要跟踪的泛型对象
                    //错误输出
                    this.EdError&lt;T&gt;(""打印错误""); // T:取当前需要跟踪的泛型对象
                </code>
            </pre>
            <p>
                *这里需要说明的，整个API的日志输出，框架会将需要记录的内容依次送入全局堆栈，以避开线程间冲突的问题，所以日志会稍有一定的延迟。
            </p>
            <h2 id=""gnqr"" name=""gnqr"">功能嵌入</h2>
            <p>
                即，Services层使用自定义的代码而不使用默认调用,如：
            </p>
            <pre>
            <code>
                    [ScriptMethod(Describe = ""这是方法的描述"")] //实现的声明
                    [CodeExecute(Var = ""result"", Code = ""test.GetList(");
                EndContext();
                BeginContext(37981, 510, true);
                WriteLiteral(@"@txt)"")] //实现的实际执行
                    [Return(Var = ""result"")] //实现的实际返回
                    Task&lt;List&lt;TestEntity&gt;&gt; Run(string txt);
                </code>
            </pre>
            <h2 id=""mxscq"" name=""mxscq"">模型生成器</h2>
            <p>敬请期待</p>
            <h2 id=""qtsjk"" name=""qtsjk"">其它数据库</h2>
            <p>敬请期待</p>
            <h2 id=""sq"" name=""sq"">社区</h2>
            <p>敬请期待</p>
            Ps.写的真TM累...
            <hr class=""major"" />

        </div>
    </section>
");
                EndContext();
            }
            );
            __Microsoft_AspNetCore_Mvc_Razor_TagHelpers_BodyTagHelper = CreateTagHelper<global::Microsoft.AspNetCore.Mvc.Razor.TagHelpers.BodyTagHelper>();
            __tagHelperExecutionContext.Add(__Microsoft_AspNetCore_Mvc_Razor_TagHelpers_BodyTagHelper);
            __tagHelperExecutionContext.AddHtmlAttribute(__tagHelperAttribute_10);
            await __tagHelperRunner.RunAsync(__tagHelperExecutionContext);
            if (!__tagHelperExecutionContext.Output.IsContentModified)
            {
                await __tagHelperExecutionContext.SetOutputContentAsync();
            }
            Write(__tagHelperExecutionContext.Output);
            __tagHelperExecutionContext = __tagHelperScopeManager.End();
            EndContext();
            BeginContext(38498, 2, true);
            WriteLiteral("\r\n");
            EndContext();
        }
        #pragma warning restore 1998
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.ViewFeatures.IModelExpressionProvider ModelExpressionProvider { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IUrlHelper Url { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.IViewComponentHelper Component { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IJsonHelper Json { get; private set; }
        [global::Microsoft.AspNetCore.Mvc.Razor.Internal.RazorInjectAttribute]
        public global::Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper<dynamic> Html { get; private set; }
    }
}
#pragma warning restore 1591
